# === SCALARS ===

scalar BigDecimal
scalar BigInt
scalar Bytes
scalar Int8
scalar Timestamp

# === ENTITIES ===

type Condition {
  # conditionId
  id: ID!
  # tokenIds
  positionIds: [BigInt!]!
  # payouts
  payoutNumerators: [BigInt!]!
  payoutDenominator: BigInt!
}
  # orderBy: id, positionIds, payoutNumerators, payoutDenominator

type FPMM {
  # FPMM address
  id: ID!
  # conditionId
  conditionId: String!
}
  # orderBy: id, conditionId

type NegRiskEvent {
  # negRiskMarketId
  id: ID!
  # Question Count
  questionCount: Int!
}
  # orderBy: id, questionCount

type UserPosition {
  # User Address + Token ID
  id: ID!
  # User Address
  user: String!
  # Token ID
  tokenId: BigInt!
  # amount of token the user holds
  amount: BigInt!
  # the avg price the user bought the token
  avgPrice: BigInt!
  # realized profits - losses
  realizedPnl: BigInt!
  # total amount of token bought
  totalBought: BigInt!
}
  # orderBy: id, user, tokenId, amount, avgPrice, realizedPnl, totalBought

type _Block_ {
  # The hash of the block
  hash: Bytes
  # The block number
  number: Int!
  # Integer representation of the timestamp stored in blocks for the chain
  timestamp: Int
  # The hash of the parent block
  parentHash: Bytes
}

"""The type for the top-level _meta field"""
type _Meta_ {
  # Information about a specific subgraph block. The hash of the block
will be null if the _meta field has a block constraint that asks for
a block number. It will be filled if the _meta field has no block constraint
and therefore asks for the latest  block
  block: _Block_!
    .hash: Bytes
    .number: Int!
    .timestamp: Int
    .parentHash: Bytes
  # The deployment ID
  deployment: String!
  # If `true`, the subgraph encountered indexing errors at some past block
  hasIndexingErrors: Boolean!
}

# === ENUMS ===

enum Aggregation_interval {
  hour
  day
}

enum OrderDirection {
  asc
  desc
}

# === SCALARS ===

scalar BigDecimal
scalar BigInt
scalar Bytes
scalar Int8
scalar Timestamp

# === ENTITIES ===

type Account {
  # User address
  id: ID!
  # Timestamp at which account first interacted with Polymarket
  creationTimestamp: BigInt!
  # Timestamp at which account most recently interacted with Polymarket
  lastSeenTimestamp: BigInt!
  # Total volume of this user's trades in USDC base units
  collateralVolume: BigInt!
  # Total number of trades performed by this user
  numTrades: BigInt!
  # Total volume of this user's trades in USDC scaled by 10^6
  scaledCollateralVolume: BigDecimal!
  # Timestamp of last Buy or Sell transaction
  lastTradedTimestamp: BigInt!
  # Markets in which user has provided liquidity
  fpmmPoolMemberships: [FpmmPoolMembership!]
    .id: ID!
    .amount: BigInt!
  # Markets in which the user has taken a position on the outcome
  marketPositions: [MarketPosition!]
    .id: ID!
    .quantityBought: BigInt!
    .quantitySold: BigInt!
    .netQuantity: BigInt!
    .valueBought: BigInt!
    .valueSold: BigInt!
    .netValue: BigInt!
    .feesPaid: BigInt!
  # Purchases and sales of shares by the user
  transactions: [Transaction!]
    .id: ID!
    .type: TradeType!
    .timestamp: BigInt!
    .tradeAmount: BigInt!
    .feeAmount: BigInt!
    .outcomeIndex: BigInt!
    .outcomeTokensAmount: BigInt!
  # Split of collateral / outcome tokens into multiple positions
  splits: [Split!]
    .id: ID!
    .timestamp: BigInt!
    .parentCollectionId: Bytes!
    .partition: [BigInt!]!
    .amount: BigInt!
  # Merge of more specific outcome tokens into collateral / more general outcome tokens
  merges: [Merge!]
    .id: ID!
    .timestamp: BigInt!
    .parentCollectionId: Bytes!
    .partition: [BigInt!]!
    .amount: BigInt!
  # Redemption of underlying collateral after a market has resolved
  redemptions: [Redemption!]
    .id: ID!
    .timestamp: BigInt!
    .parentCollectionId: Bytes!
    .indexSets: [BigInt!]!
    .payout: BigInt!
  # Profit generated from fpmm and orderbook trades, merges and redemptions
  profit: BigInt!
  # Realized profit in USDC scaled by 10^6
  scaledProfit: BigDecimal!
  # Profits in USDC base units by market
  marketProfits: [MarketProfit!]
    .id: ID!
    .profit: BigInt!
    .scaledProfit: BigDecimal!
}
  # orderBy: id, creationTimestamp, lastSeenTimestamp, collateralVolume, numTrades, scaledCollateralVolume, lastTradedTimestamp, fpmmPoolMemberships, marketPositions, transactions, splits, merges, redemptions, profit, scaledProfit, marketProfits

type Collateral {
  # Token address
  id: ID!
  name: String!
  symbol: String!
  decimals: Int!
}
  # orderBy: id, name, symbol, decimals

type Condition {
  id: ID!
  # Address which can resolve this condition
  oracle: Bytes!
  # Question ID which corresponds to this condition
  questionId: Bytes!
  # Number of possible outcomes for this condition
  outcomeSlotCount: Int!
  # Timestamp at which this condition was resolved
  resolutionTimestamp: BigInt
  # Fraction of collateral assigned to each outcome
  payouts: [BigDecimal!]
  payoutNumerators: [BigInt!]
  payoutDenominator: BigInt
  # Market makers which are trading on this condition
  fixedProductMarketMakers: [FixedProductMarketMaker!]!
    .id: ID!
    .creator: Bytes!
    .creationTimestamp: BigInt!
    .creationTransactionHash: Bytes!
    .conditionalTokenAddress: String!
    .conditions: [String!]!
    .fee: BigInt!
    .tradesQuantity: BigInt!
    .buysQuantity: BigInt!
    .sellsQuantity: BigInt!
    .liquidityAddQuantity: BigInt!
    .liquidityRemoveQuantity: BigInt!
    .collateralVolume: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .collateralBuyVolume: BigInt!
    .scaledCollateralBuyVolume: BigDecimal!
    .collateralSellVolume: BigInt!
    .scaledCollateralSellVolume: BigDecimal!
    .feeVolume: BigInt!
    .scaledFeeVolume: BigDecimal!
    .liquidityParameter: BigInt!
    .scaledLiquidityParameter: BigDecimal!
    .outcomeTokenAmounts: [BigInt!]!
    .outcomeTokenPrices: [BigDecimal!]!
    .outcomeSlotCount: Int
    .lastActiveDay: BigInt!
    .totalSupply: BigInt!
  # Hash of the resolution transaction
  resolutionHash: Bytes
}
  # orderBy: id, oracle, questionId, outcomeSlotCount, resolutionTimestamp, payouts, payoutNumerators, payoutDenominator, fixedProductMarketMakers, resolutionHash

type EnrichedOrderFilled {
  # Transaction hash + Order hash
  id: ID!
  # Transaction hash
  transactionHash: Bytes!
  # Timestamp at which transaction occurred
  timestamp: BigInt!
  # Addresses of the maker and the taker
  maker: Account!
    .id: ID!
    .creationTimestamp: BigInt!
    .lastSeenTimestamp: BigInt!
    .collateralVolume: BigInt!
    .numTrades: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .lastTradedTimestamp: BigInt!
    .profit: BigInt!
    .scaledProfit: BigDecimal!
  taker: Account!
    .id: ID!
    .creationTimestamp: BigInt!
    .lastSeenTimestamp: BigInt!
    .collateralVolume: BigInt!
    .numTrades: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .lastTradedTimestamp: BigInt!
    .profit: BigInt!
    .scaledProfit: BigDecimal!
  # Order hash
  orderHash: Bytes!
  # Market/CTF Token ID which the transaction is interacting with
  market: Orderbook!
    .id: ID!
    .tradesQuantity: BigInt!
    .buysQuantity: BigInt!
    .sellsQuantity: BigInt!
    .collateralVolume: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .collateralBuyVolume: BigInt!
    .scaledCollateralBuyVolume: BigDecimal!
    .collateralSellVolume: BigInt!
    .scaledCollateralSellVolume: BigDecimal!
    .lastActiveDay: BigInt!
  # Buy or Sell transaction
  side: TradeType!
  # Amount of collateral in trade
  size: BigInt!
  # Price of the conditional token
  price: BigDecimal!
}
  # orderBy: id, transactionHash, timestamp, maker, maker__id, maker__creationTimestamp, maker__lastSeenTimestamp, maker__collateralVolume, maker__numTrades, maker__scaledCollateralVolume, maker__lastTradedTimestamp, maker__profit, maker__scaledProfit, taker, taker__id, taker__creationTimestamp, taker__lastSeenTimestamp, taker__collateralVolume, taker__numTrades, taker__scaledCollateralVolume, taker__lastTradedTimestamp, taker__profit, taker__scaledProfit, orderHash, market, market__id, market__tradesQuantity, market__buysQuantity, market__sellsQuantity, market__collateralVolume, market__scaledCollateralVolume, market__collateralBuyVolume, market__scaledCollateralBuyVolume, market__collateralSellVolume, market__scaledCollateralSellVolume, market__lastActiveDay, side, size, price

type FixedProductMarketMaker {
  # Market maker address
  id: ID!
  # Address which deployed this market
  creator: Bytes!
  # Time at which this market was deployed
  creationTimestamp: BigInt!
  # Hash of deployment transactions
  creationTransactionHash: Bytes!
  # Token which is colleralising this market
  collateralToken: Collateral!
    .id: ID!
    .name: String!
    .symbol: String!
    .decimals: Int!
  # Conditional Token Address
  conditionalTokenAddress: String!
  # Conditions which this market is trading against
  conditions: [String!]!
  # Percentage fee of trades taken by market maker. A 2% fee is represented as 2*10^16
  fee: BigInt!
  # Number of trades of any kind against this market maker
  tradesQuantity: BigInt!
  # Number of purchases of shares from this market maker
  buysQuantity: BigInt!
  # Number of sales of shares to this market maker
  sellsQuantity: BigInt!
  # Number of times liquidity has been added to this market maker
  liquidityAddQuantity: BigInt!
  # Number of times liquidity has been removed from this market maker
  liquidityRemoveQuantity: BigInt!
  # Market volume in terms of the underlying collateral value
  collateralVolume: BigInt!
  # Volume scaled by the number of decimals of collateralToken
  scaledCollateralVolume: BigDecimal!
  # Global volume of share purchases in USDC base units
  collateralBuyVolume: BigInt!
  # Global volume of share purchases in USDC scaled by 10^6
  scaledCollateralBuyVolume: BigDecimal!
  # Global volume of share sales in USDC base units
  collateralSellVolume: BigInt!
  # Global volume of share sales in USDC scaled by 10^6
  scaledCollateralSellVolume: BigDecimal!
  # Fees collected in terms of the underlying collateral value
  feeVolume: BigInt!
  # Fees scaled by the number of decimals of collateralToken
  scaledFeeVolume: BigDecimal!
  # Constant product parameter k
  liquidityParameter: BigInt!
  scaledLiquidityParameter: BigDecimal!
  # Balances of each outcome token held by the market maker
  outcomeTokenAmounts: [BigInt!]!
  # Prices at which market maker values each outcome token
  outcomeTokenPrices: [BigDecimal!]!
  # Number of outcomes which this market maker is trading
  outcomeSlotCount: Int
  # Timestamp of last day during which someone made a trade
  lastActiveDay: BigInt!
  # Number of shares for tokens in the market maker's reserves
  totalSupply: BigInt!
  # Addresses which are supplying liquidity to the market maker
  poolMembers: [FpmmPoolMembership!]
    .id: ID!
    .amount: BigInt!
}
  # orderBy: id, creator, creationTimestamp, creationTransactionHash, collateralToken, collateralToken__id, collateralToken__name, collateralToken__symbol, collateralToken__decimals, conditionalTokenAddress, conditions, fee, tradesQuantity, buysQuantity, sellsQuantity, liquidityAddQuantity, liquidityRemoveQuantity, collateralVolume, scaledCollateralVolume, collateralBuyVolume, scaledCollateralBuyVolume, collateralSellVolume, scaledCollateralSellVolume, feeVolume, scaledFeeVolume, liquidityParameter, scaledLiquidityParameter, outcomeTokenAmounts, outcomeTokenPrices, outcomeSlotCount, lastActiveDay, totalSupply, poolMembers

type FpmmFundingAddition {
  # Transaction Hash
  id: ID!
  # Timestamp at which funding addition occurred
  timestamp: BigInt!
  # FPMM to which funding is being added
  fpmm: FixedProductMarketMaker!
    .id: ID!
    .creator: Bytes!
    .creationTimestamp: BigInt!
    .creationTransactionHash: Bytes!
    .conditionalTokenAddress: String!
    .conditions: [String!]!
    .fee: BigInt!
    .tradesQuantity: BigInt!
    .buysQuantity: BigInt!
    .sellsQuantity: BigInt!
    .liquidityAddQuantity: BigInt!
    .liquidityRemoveQuantity: BigInt!
    .collateralVolume: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .collateralBuyVolume: BigInt!
    .scaledCollateralBuyVolume: BigDecimal!
    .collateralSellVolume: BigInt!
    .scaledCollateralSellVolume: BigDecimal!
    .feeVolume: BigInt!
    .scaledFeeVolume: BigDecimal!
    .liquidityParameter: BigInt!
    .scaledLiquidityParameter: BigDecimal!
    .outcomeTokenAmounts: [BigInt!]!
    .outcomeTokenPrices: [BigDecimal!]!
    .outcomeSlotCount: Int
    .lastActiveDay: BigInt!
    .totalSupply: BigInt!
  # Account adding funding
  funder: Account!
    .id: ID!
    .creationTimestamp: BigInt!
    .lastSeenTimestamp: BigInt!
    .collateralVolume: BigInt!
    .numTrades: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .lastTradedTimestamp: BigInt!
    .profit: BigInt!
    .scaledProfit: BigDecimal!
  # Outcome tokens amounts added to FPMM
  amountsAdded: [BigInt!]!
  # Outcome tokens amounts refunded to funder
  amountsRefunded: [BigInt!]!
  # Liquidity shares minted to funder
  sharesMinted: BigInt!
}
  # orderBy: id, timestamp, fpmm, fpmm__id, fpmm__creator, fpmm__creationTimestamp, fpmm__creationTransactionHash, fpmm__conditionalTokenAddress, fpmm__fee, fpmm__tradesQuantity, fpmm__buysQuantity, fpmm__sellsQuantity, fpmm__liquidityAddQuantity, fpmm__liquidityRemoveQuantity, fpmm__collateralVolume, fpmm__scaledCollateralVolume, fpmm__collateralBuyVolume, fpmm__scaledCollateralBuyVolume, fpmm__collateralSellVolume, fpmm__scaledCollateralSellVolume, fpmm__feeVolume, fpmm__scaledFeeVolume, fpmm__liquidityParameter, fpmm__scaledLiquidityParameter, fpmm__outcomeSlotCount, fpmm__lastActiveDay, fpmm__totalSupply, funder, funder__id, funder__creationTimestamp, funder__lastSeenTimestamp, funder__collateralVolume, funder__numTrades, funder__scaledCollateralVolume, funder__lastTradedTimestamp, funder__profit, funder__scaledProfit, amountsAdded, amountsRefunded, sharesMinted

type FpmmFundingRemoval {
  # Transaction Hash
  id: ID!
  # Timestamp at which funding removal occurred
  timestamp: BigInt!
  # FPMM to which funding is being removed
  fpmm: FixedProductMarketMaker!
    .id: ID!
    .creator: Bytes!
    .creationTimestamp: BigInt!
    .creationTransactionHash: Bytes!
    .conditionalTokenAddress: String!
    .conditions: [String!]!
    .fee: BigInt!
    .tradesQuantity: BigInt!
    .buysQuantity: BigInt!
    .sellsQuantity: BigInt!
    .liquidityAddQuantity: BigInt!
    .liquidityRemoveQuantity: BigInt!
    .collateralVolume: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .collateralBuyVolume: BigInt!
    .scaledCollateralBuyVolume: BigDecimal!
    .collateralSellVolume: BigInt!
    .scaledCollateralSellVolume: BigDecimal!
    .feeVolume: BigInt!
    .scaledFeeVolume: BigDecimal!
    .liquidityParameter: BigInt!
    .scaledLiquidityParameter: BigDecimal!
    .outcomeTokenAmounts: [BigInt!]!
    .outcomeTokenPrices: [BigDecimal!]!
    .outcomeSlotCount: Int
    .lastActiveDay: BigInt!
    .totalSupply: BigInt!
  # Account removing funding
  funder: Account!
    .id: ID!
    .creationTimestamp: BigInt!
    .lastSeenTimestamp: BigInt!
    .collateralVolume: BigInt!
    .numTrades: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .lastTradedTimestamp: BigInt!
    .profit: BigInt!
    .scaledProfit: BigDecimal!
  # Outcome tokens amounts removed from FPMM
  amountsRemoved: [BigInt!]!
  collateralRemoved: BigInt!
  # Liquidity shares burned by funder
  sharesBurnt: BigInt!
}
  # orderBy: id, timestamp, fpmm, fpmm__id, fpmm__creator, fpmm__creationTimestamp, fpmm__creationTransactionHash, fpmm__conditionalTokenAddress, fpmm__fee, fpmm__tradesQuantity, fpmm__buysQuantity, fpmm__sellsQuantity, fpmm__liquidityAddQuantity, fpmm__liquidityRemoveQuantity, fpmm__collateralVolume, fpmm__scaledCollateralVolume, fpmm__collateralBuyVolume, fpmm__scaledCollateralBuyVolume, fpmm__collateralSellVolume, fpmm__scaledCollateralSellVolume, fpmm__feeVolume, fpmm__scaledFeeVolume, fpmm__liquidityParameter, fpmm__scaledLiquidityParameter, fpmm__outcomeSlotCount, fpmm__lastActiveDay, fpmm__totalSupply, funder, funder__id, funder__creationTimestamp, funder__lastSeenTimestamp, funder__collateralVolume, funder__numTrades, funder__scaledCollateralVolume, funder__lastTradedTimestamp, funder__profit, funder__scaledProfit, amountsRemoved, collateralRemoved, sharesBurnt

type FpmmPoolMembership {
  # funder address + pool address
  id: ID!
  # Market to which funder is providing funding
  pool: FixedProductMarketMaker!
    .id: ID!
    .creator: Bytes!
    .creationTimestamp: BigInt!
    .creationTransactionHash: Bytes!
    .conditionalTokenAddress: String!
    .conditions: [String!]!
    .fee: BigInt!
    .tradesQuantity: BigInt!
    .buysQuantity: BigInt!
    .sellsQuantity: BigInt!
    .liquidityAddQuantity: BigInt!
    .liquidityRemoveQuantity: BigInt!
    .collateralVolume: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .collateralBuyVolume: BigInt!
    .scaledCollateralBuyVolume: BigDecimal!
    .collateralSellVolume: BigInt!
    .scaledCollateralSellVolume: BigDecimal!
    .feeVolume: BigInt!
    .scaledFeeVolume: BigDecimal!
    .liquidityParameter: BigInt!
    .scaledLiquidityParameter: BigDecimal!
    .outcomeTokenAmounts: [BigInt!]!
    .outcomeTokenPrices: [BigDecimal!]!
    .outcomeSlotCount: Int
    .lastActiveDay: BigInt!
    .totalSupply: BigInt!
  # Account which is providing funding
  funder: Account!
    .id: ID!
    .creationTimestamp: BigInt!
    .lastSeenTimestamp: BigInt!
    .collateralVolume: BigInt!
    .numTrades: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .lastTradedTimestamp: BigInt!
    .profit: BigInt!
    .scaledProfit: BigDecimal!
  # Amount of liquidity tokens owned by funder
  amount: BigInt!
}
  # orderBy: id, pool, pool__id, pool__creator, pool__creationTimestamp, pool__creationTransactionHash, pool__conditionalTokenAddress, pool__fee, pool__tradesQuantity, pool__buysQuantity, pool__sellsQuantity, pool__liquidityAddQuantity, pool__liquidityRemoveQuantity, pool__collateralVolume, pool__scaledCollateralVolume, pool__collateralBuyVolume, pool__scaledCollateralBuyVolume, pool__collateralSellVolume, pool__scaledCollateralSellVolume, pool__feeVolume, pool__scaledFeeVolume, pool__liquidityParameter, pool__scaledLiquidityParameter, pool__outcomeSlotCount, pool__lastActiveDay, pool__totalSupply, funder, funder__id, funder__creationTimestamp, funder__lastSeenTimestamp, funder__collateralVolume, funder__numTrades, funder__scaledCollateralVolume, funder__lastTradedTimestamp, funder__profit, funder__scaledProfit, amount

type Global {
  # ID is empty string, this is a singleton
  id: ID!
  numConditions: Int!
  numOpenConditions: Int!
  numClosedConditions: Int!
  # Number of unique traders interacting with Polymarket
  numTraders: BigInt!
  # Number of trades of any kind for all market makers
  tradesQuantity: BigInt!
  # Number of purchases of shares from any market maker
  buysQuantity: BigInt!
  # Number of sales of shares to any market maker
  sellsQuantity: BigInt!
  # Global volume in USDC base units
  collateralVolume: BigInt!
  # Global volume in USDC scaled by 10^6
  scaledCollateralVolume: BigDecimal!
  # Global fees in USDC base units
  collateralFees: BigInt!
  # Global fees in USDC scaled by 10^6
  scaledCollateralFees: BigDecimal!
  # Global volume of share purchases in USDC base units
  collateralBuyVolume: BigInt!
  # Global volume of share purchases in USDC scaled by 10^6
  scaledCollateralBuyVolume: BigDecimal!
  # Global volume of share sales in USDC base units
  collateralSellVolume: BigInt!
  # Global volume of share sales in USDC scaled by 10^6
  scaledCollateralSellVolume: BigDecimal!
}
  # orderBy: id, numConditions, numOpenConditions, numClosedConditions, numTraders, tradesQuantity, buysQuantity, sellsQuantity, collateralVolume, scaledCollateralVolume, collateralFees, scaledCollateralFees, collateralBuyVolume, scaledCollateralBuyVolume, collateralSellVolume, scaledCollateralSellVolume

type MarketData {
  # ERC1155 TokenID of the CTF Asset
  id: ID!
  # Condition that the token is linked to
  condition: Condition!
    .id: ID!
    .oracle: Bytes!
    .questionId: Bytes!
    .outcomeSlotCount: Int!
    .resolutionTimestamp: BigInt
    .payouts: [BigDecimal!]
    .payoutNumerators: [BigInt!]
    .payoutDenominator: BigInt
    .resolutionHash: Bytes
  # Outcome Index, may not be present if an FPMM is not created
  outcomeIndex: BigInt
  # The linked FixedProductMarketMaker
  fpmm: FixedProductMarketMaker
    .id: ID!
    .creator: Bytes!
    .creationTimestamp: BigInt!
    .creationTransactionHash: Bytes!
    .conditionalTokenAddress: String!
    .conditions: [String!]!
    .fee: BigInt!
    .tradesQuantity: BigInt!
    .buysQuantity: BigInt!
    .sellsQuantity: BigInt!
    .liquidityAddQuantity: BigInt!
    .liquidityRemoveQuantity: BigInt!
    .collateralVolume: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .collateralBuyVolume: BigInt!
    .scaledCollateralBuyVolume: BigDecimal!
    .collateralSellVolume: BigInt!
    .scaledCollateralSellVolume: BigDecimal!
    .feeVolume: BigInt!
    .scaledFeeVolume: BigDecimal!
    .liquidityParameter: BigInt!
    .scaledLiquidityParameter: BigDecimal!
    .outcomeTokenAmounts: [BigInt!]!
    .outcomeTokenPrices: [BigDecimal!]!
    .outcomeSlotCount: Int
    .lastActiveDay: BigInt!
    .totalSupply: BigInt!
  # The most recent onchain price of the asset on the orderbook
  priceOrderbook: BigDecimal
}
  # orderBy: id, condition, condition__id, condition__oracle, condition__questionId, condition__outcomeSlotCount, condition__resolutionTimestamp, condition__payoutDenominator, condition__resolutionHash, outcomeIndex, fpmm, fpmm__id, fpmm__creator, fpmm__creationTimestamp, fpmm__creationTransactionHash, fpmm__conditionalTokenAddress, fpmm__fee, fpmm__tradesQuantity, fpmm__buysQuantity, fpmm__sellsQuantity, fpmm__liquidityAddQuantity, fpmm__liquidityRemoveQuantity, fpmm__collateralVolume, fpmm__scaledCollateralVolume, fpmm__collateralBuyVolume, fpmm__scaledCollateralBuyVolume, fpmm__collateralSellVolume, fpmm__scaledCollateralSellVolume, fpmm__feeVolume, fpmm__scaledFeeVolume, fpmm__liquidityParameter, fpmm__scaledLiquidityParameter, fpmm__outcomeSlotCount, fpmm__lastActiveDay, fpmm__totalSupply, priceOrderbook

type MarketPosition {
  id: ID!
  # Market/tokenId on which this position is on
  market: MarketData!
    .id: ID!
    .outcomeIndex: BigInt
    .priceOrderbook: BigDecimal
  # Address which holds this position
  user: Account!
    .id: ID!
    .creationTimestamp: BigInt!
    .lastSeenTimestamp: BigInt!
    .collateralVolume: BigInt!
    .numTrades: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .lastTradedTimestamp: BigInt!
    .profit: BigInt!
    .scaledProfit: BigDecimal!
  # Number of outcome shares that the user has ever bought
  quantityBought: BigInt!
  # Number of outcome shares that the user has ever sold
  quantitySold: BigInt!
  # Number of outcome shares that the user current has
  netQuantity: BigInt!
  # Total value of outcome shares that the user has bought
  valueBought: BigInt!
  # Total value of outcome shares that the user has sold
  valueSold: BigInt!
  # Total value paid by the user to enter this position
  netValue: BigInt!
  # Total amount of fees paid by user in relation to this position
  feesPaid: BigInt!
}
  # orderBy: id, market, market__id, market__outcomeIndex, market__priceOrderbook, user, user__id, user__creationTimestamp, user__lastSeenTimestamp, user__collateralVolume, user__numTrades, user__scaledCollateralVolume, user__lastTradedTimestamp, user__profit, user__scaledProfit, quantityBought, quantitySold, netQuantity, valueBought, valueSold, netValue, feesPaid

type MarketProfit {
  # Keyed on ConditionID + user
  id: ID!
  # User address
  user: Account!
    .id: ID!
    .creationTimestamp: BigInt!
    .lastSeenTimestamp: BigInt!
    .collateralVolume: BigInt!
    .numTrades: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .lastTradedTimestamp: BigInt!
    .profit: BigInt!
    .scaledProfit: BigDecimal!
  # The ConditionID, used as the link between YES/NO tokens
  condition: Condition!
    .id: ID!
    .oracle: Bytes!
    .questionId: Bytes!
    .outcomeSlotCount: Int!
    .resolutionTimestamp: BigInt
    .payouts: [BigDecimal!]
    .payoutNumerators: [BigInt!]
    .payoutDenominator: BigInt
    .resolutionHash: Bytes
  # Profit in USDC base units per market per account
  profit: BigInt!
  # Profit in USDC scaled by 10^6
  scaledProfit: BigDecimal!
}
  # orderBy: id, user, user__id, user__creationTimestamp, user__lastSeenTimestamp, user__collateralVolume, user__numTrades, user__scaledCollateralVolume, user__lastTradedTimestamp, user__profit, user__scaledProfit, condition, condition__id, condition__oracle, condition__questionId, condition__outcomeSlotCount, condition__resolutionTimestamp, condition__payoutDenominator, condition__resolutionHash, profit, scaledProfit

type Merge {
  # Transaction Hash
  id: ID!
  # Timestamp at which merge occurred
  timestamp: BigInt!
  # Address which is performing this merge
  stakeholder: Account!
    .id: ID!
    .creationTimestamp: BigInt!
    .lastSeenTimestamp: BigInt!
    .collateralVolume: BigInt!
    .numTrades: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .lastTradedTimestamp: BigInt!
    .profit: BigInt!
    .scaledProfit: BigDecimal!
  # Token which is collateralising positions being merged
  collateralToken: Collateral!
    .id: ID!
    .name: String!
    .symbol: String!
    .decimals: Int!
  parentCollectionId: Bytes!
  # Condition on which merge is occuring
  condition: Condition!
    .id: ID!
    .oracle: Bytes!
    .questionId: Bytes!
    .outcomeSlotCount: Int!
    .resolutionTimestamp: BigInt
    .payouts: [BigDecimal!]
    .payoutNumerators: [BigInt!]
    .payoutDenominator: BigInt
    .resolutionHash: Bytes
  partition: [BigInt!]!
  # The amount of outcome tokens being merged
  amount: BigInt!
}
  # orderBy: id, timestamp, stakeholder, stakeholder__id, stakeholder__creationTimestamp, stakeholder__lastSeenTimestamp, stakeholder__collateralVolume, stakeholder__numTrades, stakeholder__scaledCollateralVolume, stakeholder__lastTradedTimestamp, stakeholder__profit, stakeholder__scaledProfit, collateralToken, collateralToken__id, collateralToken__name, collateralToken__symbol, collateralToken__decimals, parentCollectionId, condition, condition__id, condition__oracle, condition__questionId, condition__outcomeSlotCount, condition__resolutionTimestamp, condition__payoutDenominator, condition__resolutionHash, partition, amount

type OrderFilledEvent {
  # Transaction hash + Order hash
  id: ID!
  # Transaction hash
  transactionHash: Bytes!
  # Timestamp at which filled occurred
  timestamp: BigInt!
  orderHash: Bytes!
  # Addresses of the maker and the taker
  maker: Account!
    .id: ID!
    .creationTimestamp: BigInt!
    .lastSeenTimestamp: BigInt!
    .collateralVolume: BigInt!
    .numTrades: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .lastTradedTimestamp: BigInt!
    .profit: BigInt!
    .scaledProfit: BigDecimal!
  taker: Account!
    .id: ID!
    .creationTimestamp: BigInt!
    .lastSeenTimestamp: BigInt!
    .collateralVolume: BigInt!
    .numTrades: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .lastTradedTimestamp: BigInt!
    .profit: BigInt!
    .scaledProfit: BigDecimal!
  # Maker assetId
  makerAssetId: String!
  # Taker assetId
  takerAssetId: String!
  # Maker amount filled
  makerAmountFilled: BigInt!
  # Taker amount filled
  takerAmountFilled: BigInt!
  # Fee paid by the order maker
  fee: BigInt!
}
  # orderBy: id, transactionHash, timestamp, orderHash, maker, maker__id, maker__creationTimestamp, maker__lastSeenTimestamp, maker__collateralVolume, maker__numTrades, maker__scaledCollateralVolume, maker__lastTradedTimestamp, maker__profit, maker__scaledProfit, taker, taker__id, taker__creationTimestamp, taker__lastSeenTimestamp, taker__collateralVolume, taker__numTrades, taker__scaledCollateralVolume, taker__lastTradedTimestamp, taker__profit, taker__scaledProfit, makerAssetId, takerAssetId, makerAmountFilled, takerAmountFilled, fee

type Orderbook {
  # Token Id
  id: ID!
  # Number of trades of any kind against this order book
  tradesQuantity: BigInt!
  # Number of purchases of shares from this order book
  buysQuantity: BigInt!
  # Number of sales of shares to this order book
  sellsQuantity: BigInt!
  # Market volume in terms of the underlying collateral value
  collateralVolume: BigInt!
  # Volume scaled by the number of decimals of collateralToken
  scaledCollateralVolume: BigDecimal!
  # Global volume of share purchases in USDC base units
  collateralBuyVolume: BigInt!
  # Global volume of share purchases in USDC scaled by 10^6
  scaledCollateralBuyVolume: BigDecimal!
  # Global volume of share sales in USDC base units
  collateralSellVolume: BigInt!
  # Global volume of share sales in USDC scaled by 10^6
  scaledCollateralSellVolume: BigDecimal!
  # Timestamp of last day during which someone made a trade
  lastActiveDay: BigInt!
}
  # orderBy: id, tradesQuantity, buysQuantity, sellsQuantity, collateralVolume, scaledCollateralVolume, collateralBuyVolume, scaledCollateralBuyVolume, collateralSellVolume, scaledCollateralSellVolume, lastActiveDay

type OrdersMatchedEvent {
  # Transaction Hash
  id: ID!
  # Timestamp at which filled occurred
  timestamp: BigInt!
  # Maker asset Id
  makerAssetID: BigInt!
  # Taker asset Id
  takerAssetID: BigInt!
  # Maker amount filled
  makerAmountFilled: BigInt!
  # Taker amount filled
  takerAmountFilled: BigInt!
}
  # orderBy: id, timestamp, makerAssetID, takerAssetID, makerAmountFilled, takerAmountFilled

type OrdersMatchedGlobal {
  # ID is empty string, this is a singleton
  id: ID!
  # Number of trades of any kind for all order books
  tradesQuantity: BigInt!
  # Number of purchases of shares from any order book
  buysQuantity: BigInt!
  # Number of sales of shares to any order book
  sellsQuantity: BigInt!
  # Global volume in USDC base units
  collateralVolume: BigDecimal!
  # Global volume in USDC scaled by 10^6
  scaledCollateralVolume: BigDecimal!
  # Global volume of share purchases in USDC base units
  collateralBuyVolume: BigDecimal!
  # Global volume of share purchases in USDC scaled by 10^6
  scaledCollateralBuyVolume: BigDecimal!
  # Global volume of share sales in USDC base units
  collateralSellVolume: BigDecimal!
  # Global volume of share sales in USDC scaled by 10^6
  scaledCollateralSellVolume: BigDecimal!
}
  # orderBy: id, tradesQuantity, buysQuantity, sellsQuantity, collateralVolume, scaledCollateralVolume, collateralBuyVolume, scaledCollateralBuyVolume, collateralSellVolume, scaledCollateralSellVolume

type Redemption {
  # Transaction Hash
  id: ID!
  # Timestamp at which redemption occurred
  timestamp: BigInt!
  # Address which is redeeming these outcomes
  redeemer: Account!
    .id: ID!
    .creationTimestamp: BigInt!
    .lastSeenTimestamp: BigInt!
    .collateralVolume: BigInt!
    .numTrades: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .lastTradedTimestamp: BigInt!
    .profit: BigInt!
    .scaledProfit: BigDecimal!
  # Token which is being claimed in return for outcome tokens
  collateralToken: Collateral!
    .id: ID!
    .name: String!
    .symbol: String!
    .decimals: Int!
  parentCollectionId: Bytes!
  # Condition on which redemption is occuring
  condition: Condition!
    .id: ID!
    .oracle: Bytes!
    .questionId: Bytes!
    .outcomeSlotCount: Int!
    .resolutionTimestamp: BigInt
    .payouts: [BigDecimal!]
    .payoutNumerators: [BigInt!]
    .payoutDenominator: BigInt
    .resolutionHash: Bytes
  # Outcomes which are being redeemed
  indexSets: [BigInt!]!
  # The amount of collateral being claimed
  payout: BigInt!
}
  # orderBy: id, timestamp, redeemer, redeemer__id, redeemer__creationTimestamp, redeemer__lastSeenTimestamp, redeemer__collateralVolume, redeemer__numTrades, redeemer__scaledCollateralVolume, redeemer__lastTradedTimestamp, redeemer__profit, redeemer__scaledProfit, collateralToken, collateralToken__id, collateralToken__name, collateralToken__symbol, collateralToken__decimals, parentCollectionId, condition, condition__id, condition__oracle, condition__questionId, condition__outcomeSlotCount, condition__resolutionTimestamp, condition__payoutDenominator, condition__resolutionHash, indexSets, payout

type Split {
  # Transaction Hash
  id: ID!
  # Timestamp at which split occurred
  timestamp: BigInt!
  # Address which is performing this split
  stakeholder: Account!
    .id: ID!
    .creationTimestamp: BigInt!
    .lastSeenTimestamp: BigInt!
    .collateralVolume: BigInt!
    .numTrades: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .lastTradedTimestamp: BigInt!
    .profit: BigInt!
    .scaledProfit: BigDecimal!
  # Token which is collateralising positions being split
  collateralToken: Collateral!
    .id: ID!
    .name: String!
    .symbol: String!
    .decimals: Int!
  parentCollectionId: Bytes!
  # Condition on which split is occuring
  condition: Condition!
    .id: ID!
    .oracle: Bytes!
    .questionId: Bytes!
    .outcomeSlotCount: Int!
    .resolutionTimestamp: BigInt
    .payouts: [BigDecimal!]
    .payoutNumerators: [BigInt!]
    .payoutDenominator: BigInt
    .resolutionHash: Bytes
  partition: [BigInt!]!
  # The amount of collateral/outcome tokens being split
  amount: BigInt!
}
  # orderBy: id, timestamp, stakeholder, stakeholder__id, stakeholder__creationTimestamp, stakeholder__lastSeenTimestamp, stakeholder__collateralVolume, stakeholder__numTrades, stakeholder__scaledCollateralVolume, stakeholder__lastTradedTimestamp, stakeholder__profit, stakeholder__scaledProfit, collateralToken, collateralToken__id, collateralToken__name, collateralToken__symbol, collateralToken__decimals, parentCollectionId, condition, condition__id, condition__oracle, condition__questionId, condition__outcomeSlotCount, condition__resolutionTimestamp, condition__payoutDenominator, condition__resolutionHash, partition, amount

type Transaction {
  # Transaction Hash
  id: ID!
  # Buy or Sell transaction
  type: TradeType!
  # Timestamp at which transaction occurred
  timestamp: BigInt!
  # Market which transaction is interacting with
  market: FixedProductMarketMaker!
    .id: ID!
    .creator: Bytes!
    .creationTimestamp: BigInt!
    .creationTransactionHash: Bytes!
    .conditionalTokenAddress: String!
    .conditions: [String!]!
    .fee: BigInt!
    .tradesQuantity: BigInt!
    .buysQuantity: BigInt!
    .sellsQuantity: BigInt!
    .liquidityAddQuantity: BigInt!
    .liquidityRemoveQuantity: BigInt!
    .collateralVolume: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .collateralBuyVolume: BigInt!
    .scaledCollateralBuyVolume: BigDecimal!
    .collateralSellVolume: BigInt!
    .scaledCollateralSellVolume: BigDecimal!
    .feeVolume: BigInt!
    .scaledFeeVolume: BigDecimal!
    .liquidityParameter: BigInt!
    .scaledLiquidityParameter: BigDecimal!
    .outcomeTokenAmounts: [BigInt!]!
    .outcomeTokenPrices: [BigDecimal!]!
    .outcomeSlotCount: Int
    .lastActiveDay: BigInt!
    .totalSupply: BigInt!
  # Account performing transaction
  user: Account!
    .id: ID!
    .creationTimestamp: BigInt!
    .lastSeenTimestamp: BigInt!
    .collateralVolume: BigInt!
    .numTrades: BigInt!
    .scaledCollateralVolume: BigDecimal!
    .lastTradedTimestamp: BigInt!
    .profit: BigInt!
    .scaledProfit: BigDecimal!
  # Amount of collateral in trade
  tradeAmount: BigInt!
  # Amount of collateral paid in fees
  feeAmount: BigInt!
  # Index of outcome token being bought or sold
  outcomeIndex: BigInt!
  # Amount of outcome tokens being bought or sold
  outcomeTokensAmount: BigInt!
}
  # orderBy: id, type, timestamp, market, market__id, market__creator, market__creationTimestamp, market__creationTransactionHash, market__conditionalTokenAddress, market__fee, market__tradesQuantity, market__buysQuantity, market__sellsQuantity, market__liquidityAddQuantity, market__liquidityRemoveQuantity, market__collateralVolume, market__scaledCollateralVolume, market__collateralBuyVolume, market__scaledCollateralBuyVolume, market__collateralSellVolume, market__scaledCollateralSellVolume, market__feeVolume, market__scaledFeeVolume, market__liquidityParameter, market__scaledLiquidityParameter, market__outcomeSlotCount, market__lastActiveDay, market__totalSupply, user, user__id, user__creationTimestamp, user__lastSeenTimestamp, user__collateralVolume, user__numTrades, user__scaledCollateralVolume, user__lastTradedTimestamp, user__profit, user__scaledProfit, tradeAmount, feeAmount, outcomeIndex, outcomeTokensAmount

type _Block_ {
  # The hash of the block
  hash: Bytes
  # The block number
  number: Int!
  # Integer representation of the timestamp stored in blocks for the chain
  timestamp: Int
  # The hash of the parent block
  parentHash: Bytes
}

"""The type for the top-level _meta field"""
type _Meta_ {
  # Information about a specific subgraph block. The hash of the block
will be null if the _meta field has a block constraint that asks for
a block number. It will be filled if the _meta field has no block constraint
and therefore asks for the latest  block
  block: _Block_!
    .hash: Bytes
    .number: Int!
    .timestamp: Int
    .parentHash: Bytes
  # The deployment ID
  deployment: String!
  # If `true`, the subgraph encountered indexing errors at some past block
  hasIndexingErrors: Boolean!
}

# === ENUMS ===

enum Aggregation_interval {
  hour
  day
}

enum OrderDirection {
  asc
  desc
}
